.model small
swap macro stroka, metka		; макрос переворота строки
	mov ax, cn			; разделить количество 
	mov bl, 6			; байт в половине строки
	xor bh, bh			; на 6 чтобы получить
	xor dx, dx			; ту часть строки,
	div bx				; которую мне надо
	mov dx, ax			; перевернуть (половину от половины)
	mov cx, ax			; в пикселях. в dx запомнил количество
metka:					; переворачивать в цикле
	mov bx, cx			; запомнить количество на данную итерацию
	mov ax, ds			; переместить в es
	mov es, ax			; ds для работы строковой
	lea si, stroka			; функции. также заполнить 
	mov ax, dx			; другие регистры
	sub ax, bx			; для работы movsb: из ds:si в es:di
	mov cx, 3			; умножить на три для получения количества байт
	push dx				; Запомнить dx, потому что в нём будет переполнение
	mul cx				; умножить на 3
	pop dx				; вытащить dx обратно
	add si, ax			; ax - адрес от начала строки
	push si				; запомнить его
	lea di, obmenl			; пишем в обмен из начала
	mov cx, 3			; три байта
	rep movsb			; вызов функции переноса
	mov ax, dx			; дальше из
	sub ax, bx			; конца строки
	mov cx, 3			; переносим в начало
	push dx				; выполняя
	mul cx				; те же операции
	pop dx				; по заполнению регистров
	add ax, 3			; что и ранее
	lea cx, stroka			; адрес той строки, которую передали как параметр
	add cx, cn			; далее считаем
	sub cx, ax			; количество байт
	mov si, cx			; которые надо
	pop di				; передать 
	push si				; из одного места
	mov cx, 3			; в другое
	rep movsb			; перенос
	pop di				; получем ранее сохраненный адрес конца строки
	lea si, obmenl			; передаём туда из обмена
	mov cx, 3			; в котором хранятся 
	rep movsb			; байты, которые были в начале строки
	mov cx, bx			; количество пикселей на данную итерацию
	loop metka			; повторить в цикле
endm					; конец описания макроса
read macro kol, mesto			; макрос чтения из файла некоторого количества байт в некоторое место
	mov cx, kol			; количество байт
	lea dx, mesto			; адрес места
	mov bx, handle			; итендификатор файла
	mov ah, 3Fh			; процедура чтения
	int 21h				; вызов процедуры
endm					; конец описания макроса
write macro kol, mesto, metk		; макрос записи некоторого количества байт в файл из некоторого места
	cmp cx, 0000			; сравниваем с нулём (необходимо для признака)
	je metk				; если 0, то выходим сразу
	mov ah, 40h			; код процедуры
	mov bx, handlenew		; итендификатор файла
	mov cx, kol			; количество байт
	lea dx, mesto			; место откуда пишем
	int 21h				; вызов процедуры
	metk:				; метка на выход
endm					; конец описания макроса

.stack 100h
.data
filename db 'ttt.bmp', 0		; Имя файла
handle dw ?				; Итендификатор файла
string dw ?				; Количество строк в файле
cn dw ?					; Количество столбцов в файле
strl db 4096 dup('1')			; Левая половина строки
strr db 4096 dup('2')			; Правая половина строки
obmenl db '123'				; Место для обмена
filenew db 'tttnew.bmp', 0		; Имя нового файла
handlenew dw ?				; Итендификатор нового файла
kkk dw 0				; Признак конца строки
ksd dw 3				; Количество байт в признаке
odin db '789'				; Место для одного байта при нечётном количестве столбцов
cnreal dw ?				; Неизменённое количество столбцов
.code
start:
	mov ax, @data
	mov ds, ax
	call open			; открыть файл
;	read 4096, strl			; Было нужно для отладки
	call ini			; Считать информацию из файла
	call create			; Создать новый файл
repeat:					; Повторять в цикле
	read cn, strl			; Считать левую часть строки
	mov dx, 0			; Обнулить место для остатка от деления
	mov ax, cnreal			; Далее разделить количество 
	mov bx, 2			; пикселей в строке на 2 для того
	div bx				; чтобы узнать надо ли считывать
	cmp dx, 0000			; Серединный пиксель
	je m7				; Если не надо, то
	read 3, odin			; перейти к метке7
m7:					; Если надо, то считать его
	swap strl, m1			; перевернуть левую строку
	read cn, strr			; считать правую строку
	push ax				; Запомнить количество реально считанных байтов
	swap strr, m2			; Перевернуть правую строку
	mov cx, 1			; Записать в cx 1 для 100% прохождения проверки
	write cn, strr, m3		; Записать в новый файл правую строку
	mov dx, 0			; Опять проверить серединный
	mov ax, cnreal			; байт и если он есть
	mov bx, 2			; то записать в новый
	div bx				; файл тот самый байт
	cmp dx, 0000			; который ранее был сохранен
	je m8				; если его нет, то
	mov cx, 3			; пропустить этот
	write 3, odin, m9		; шаг и сразу перейти
m8:					; к следующему шагу
	mov cx, 2			; Записать в cx число отличное от 0 для
	write cn, strl, m4		; успешного прохождения проверки при записи в файл
	pop ax				; Вытащить ax обратно
	cmp ax, 00			; проверить не кончился ли файл
	je theend			; если да, то перейти в конец
	mov cx, ksd			; если нет, то записать в 
	write cx, kkk, m5		; новый файл признак конца строки
	mov bx, handle			; и переместить курсор в изначальном файле
	call sdvig			; на следующую строку
jmp repeat				; Повторить цикл
theend:					; метка конца программы
	call close			; Закрыть все файлы
	mov ah, 4Ch			; Выйти из
	int 21h				; программы
create proc				; Процедура создания файла
	mov ah, 3ch			; Код создания
	mov cx, 00			; атрибут обычного файла
	lea dx, filenew			; Имя нового файла
	int 21h				; вызов процедуры
	mov handlenew, ax		; записать итендификатор
	mov ah, 40h			; код записи в файл
	mov bx, handlenew		; итендификатор файлы
	mov cx, 36h			; записать 54 байта
	lea dx, strl			; начиная с адреса strl
	int 21h				; вызов процедуры
	ret				; вернуться в программу
endp					; конец описания процедуры
ini proc				; процедура изначального заполнения информации
	read 36h, strl			; Считать информационные 54 байта
	mov al, ds:[0020h]		; считать 
	mov ah, ds:[0021h]		; количество столбцов
	mov bl, ds:[0024h]		; считать
	mov bh, ds:[0025h]		; количество строк
	mov cn, ax			; запомнить 
	mov string, bx			; это в памяти
	mov cnreal, ax			; запомнить реальное количество столбцов
	mov al, ds:[0010h]		; считать
	mov ah, ds:[0011h]		; количество 
	mov dl, ds:[0012h]		; байтов 
	mov dh, ds:[0013h]		; в файле
	sub ax, 36h			; вычесть 54 информационных
	mov bx, string			; разделить на
	div bx				; количество строк
	mov cx, ax			; запомнить это число
	mov ax, cn			; умножить количенство столбцов (пикселей в строке)
	mov bx, 3			; на три чтобы
	mul bx				; получить количество байт на строку
	sub cx, ax			; вычесть из байт выделяемых на строку количество байт 
	mov ksd, cx			; в строке, которыми кодируются пиксели и записать это
	mov ax, cn			; далее разделить
	mov dx, 0			; количество байт в строке
	mov bx, 2			; на два и умножить на три
	div bx				; чтобы получить количество
	mov cx, 3			; считываемых элементов
	mul cx				; в одной половине строки
	mov cn, ax			; записать это число в память
	ret				; выйти из процедуры
endp					; конец описания процедуры
open proc				; процедуры открытия файла
	mov ah, 3Dh			; код открытия
	lea dx, filename		; имя файла
	mov al, 02			; открыть на все права
	int 21h				; вызов процедуры
	mov handle, ax			; записать итендификатор в память
	ret				; выйти в программу
endp					; конец описания процедуры
close proc				; процедура закрытия файла
	mov ah, 3Eh			; код данной процедуры
	mov bx, handle			; итендификатор изначального файла
	int 21h				; вызов процедуры
	mov bx, handlenew		; итендификатор нового файла
	int 21h				; вызов процедуры
	ret				; вернуться в программу
endp					; конец описания процедуры
sdvig proc				; процедура перемещения курсора в файле
	mov dx, ksd			; передвинуть на ksd байт
	cmp dx, 0000			; если 0 то
	je endd				; сразу выйти
	mov ah, 42h			; код процедуры
	mov al, 01			; начинать передвигать от текущего положения курсора
	mov cx, 00			; смещение до FF
	int 21h				; вызов процедуры
	endd:				; метка выхода
	ret				; вернуться в программу
endp					; конец описания процедуры
end start				; конец программы